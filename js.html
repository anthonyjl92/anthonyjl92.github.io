var - don't use anymore bc it's globally scoped (can have conflicts if same name)

let - allows value to be reassigned
const - does not allow value to be reassigned
-both have block level scopes

number, string, boolean, undefined, null
typeof (x)-> returns data type
typeof null -> object => this is an error


string concat - ES6 template string
let name='bob'
let age=12
`Age ${age} Name ${name}` => Age 12 Name bob

string methods
substring 
length
toUpperCase
toLowerCase
split


Array 
.push
.unshift
.length
.indexOf


const person = {
    firstName:'John'
    lasName: 'Bob'
    addr: {
        street:'50 main',
        city: 'Boston',
        state:'MA'
    }
    hobbies: [x,y,z]
}

person.hobbies[1] => y
person.addr.street => 50 main

const {firstName,lastName} = person   => console.log (firstName) => John
const {firstName,lastName,addr:{city}} = person   => console.log (city) => 59 main

person.email = 'bob@gmail.com' => adds to the object


to convert object to JSON 
-> need to have dbl quotes around keys and dbl quotes around strings
-> no single quotes
-> JSON.stringify(array) => converts to JSON


forEach, map, filter => high order array methods takes a function as parameter

arrName.forEach(function(ele){
    return ele;
});

//returns an array
const newArr= arrName.map(function(ele){
    return ele+5;
});


const newArr =arrName.filter(function(ele){
    return ele === 0;
});


can chain

const newArr =arrName.filter(function(ele){
    return ele === 0;
}).map(function(){
    return ele+5
});


const color = x>10 ? blue:red
-> means if x>10 then blue else red



es5
function addNums(n1,n2){
    return n1+n2;
}

ES6
single statement, no return keyword
const adNums => (n1,n2) =>  n1+n2

multi -add {}
const adNums => (n1,n2) => {return n1+n2} 

arrName.forEach((ele) => console.log(ele));

Es5 
constructor
function Person (f,l,dob){
    this.f=f;
    this.l=l;
    this.dob=dob;
}

Person.prototype.getyear = function(){
    return this.dob;
}

const person1= new Person('a','b','1995')


ES6, adds things to prototype in an easier way
class Person{
    constructor(f,l,dob){
        this.f=f;
        this.l=l;
        this.dob=dob;
    }

    getyear(){
        return this.dob;
    }

}


document.querySelector('param') // can be id, element, class => returns first instance

document.querySelectorAll('param') // gets all elements with param => returns an array of matching

once selected - can manipulate


eventListeners on ids, classes or elements

.preventDefault() - prevents default behavior